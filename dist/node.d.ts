export declare const NEXT: unique symbol;
export declare const PREV: unique symbol;
export declare const START: unique symbol;
export declare const END: unique symbol;
export declare const PARENT: unique symbol;
export declare abstract class Node extends EventTarget {
    [NEXT]?: Node;
    [PREV]?: Node;
    get endNode(): Node;
    get startNode(): Node;
    _attach(prev: Node | null, next: Node, parent: ParentNode): void;
    _linkr(node: Node): void;
    _linkl(node?: Node): void;
    _detach(newOwner?: Document | null): this;
    _owner?: Document;
    parentNode?: ParentNode | null;
    abstract get nodeType(): number;
    abstract get nodeName(): string;
    get ownerDocument(): Document | null;
    set ownerDocument(doc: Document | null);
    get nodeValue(): string | null;
    set nodeValue(data: string | null);
    get textContent(): string | null;
    set textContent(data: string | null);
    isSameNode(node: Node): boolean;
    abstract isEqualNode(node: Node): boolean;
    remove(): void;
    getRootNode(): Node;
    appendChild(node: Node): void;
    get firstChild(): ChildNode | null;
    get lastChild(): ChildNode | null;
    get previousSibling(): ChildNode | null;
    get nextSibling(): ChildNode | null;
    get parentElement(): Element | null;
    get childNodes(): NodeList;
    hasChildNodes(): boolean;
    get baseURI(): string;
    lookupNamespaceURI(prefix: string): string | null;
    isDefaultNamespace(namespaceURI: string): boolean;
    lookupPrefix(ns: string): string | null;
    cloneNode(deep?: boolean): Node;
    normalize(): void;
    compareDocumentPosition(that: Node): number;
    contains(node?: Node | null): boolean;
    insertBefore(node: ChildNode, before?: ChildNode | EndNode | null): any;
    _replace(node: ChildNode, child: ChildNode): void;
    replaceChild(node: ChildNode, child: ChildNode): void;
    removeChild(node: ChildNode): void;
    static get ELEMENT_NODE(): number;
    get ELEMENT_NODE(): number;
    static get ATTRIBUTE_NODE(): number;
    get ATTRIBUTE_NODE(): number;
    static get TEXT_NODE(): number;
    get TEXT_NODE(): number;
    static get CDATA_SECTION_NODE(): number;
    get CDATA_SECTION_NODE(): number;
    static get ENTITY_REFERENCE_NODE(): number;
    get ENTITY_REFERENCE_NODE(): number;
    static get ENTITY_NODE(): number;
    get ENTITY_NODE(): number;
    static get PROCESSING_INSTRUCTION_NODE(): number;
    get PROCESSING_INSTRUCTION_NODE(): number;
    static get COMMENT_NODE(): number;
    get COMMENT_NODE(): number;
    static get DOCUMENT_NODE(): number;
    get DOCUMENT_NODE(): number;
    static get DOCUMENT_TYPE_NODE(): number;
    get DOCUMENT_TYPE_NODE(): number;
    static get DOCUMENT_FRAGMENT_NODE(): number;
    get DOCUMENT_FRAGMENT_NODE(): number;
    static get NOTATION_NODE(): number;
    get NOTATION_NODE(): number;
    _enumAncestorTargets(): Generator<ParentNode, void, unknown>;
}
export declare abstract class NodeList {
    abstract get length(): number;
}
export declare class Children extends NodeList {
    parent: ChildNode;
    constructor(parent: ChildNode);
    [i: number]: ChildNode;
    item(index: number): ChildNode | null;
    get length(): number;
    [Symbol.iterator](): Iterator<ChildNode>;
    keys(): Generator<number, void, unknown>;
    values(): Generator<ChildNode, void, unknown>;
    entries(): Generator<(number | ChildNode)[], void, unknown>;
    forEach(callback: any, thisArg: any): void;
}
import { EventTarget } from "./event-target.js";
import { ChildNode } from "./child-node.js";
import { EndNode, ParentNode } from "./parent-node.js";
import { Element } from "./element.js";
import { Document } from "./document.js";
